<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no" />
<meta name="mobile-web-app-capable" content="yes"/>
<title>Reversi Play - Free HTML5 Othello Game</title>
<script src="//code.jquery.com/jquery-2.2.0.min.js"></script>
<style type="text/css">
div.container {
    width: 100%;
    border: 1px solid gray;
}

header, footer {
    padding: 0;
    color: white;
    background-color: black;
    clear: left;
    text-align: center;
}

header p {
 	color: white;
    background-color: black;
}

div.gamepanel {
    padding: 0;
    margin:0;
    overflow: hidden;
    text-align: center;
}
</style>
</head>
<body>
	<div class="container">
		<header>
		   <p>This is Free reversi play</p>
		</header>
		<div class="gamepanel">
			<canvas id="gameBoard" width="1280" height="1280"></canvas>
		</div>
		<footer>
			Copyright			
		</footer>
	</div>
	
	<script>
	var GameBoard = function(canvasId, size, listener) {
		const NONE = "N";
		const WHITE = "W";
		const BLACK = "B";
		const WHITE_COLOR = "#FFF";
		const BLACK_COLOR = "#000";
		const VALID_COLOR = "rgba(255, 255, 0, 0.7)";
// 		const VALID_COLOR = "Red";
		const PIECE_MARGIN = 0.8;

		this.canvas = document.getElementById(canvasId);
		this.ctx = this.canvas.getContext("2d");
		this.listener = listener;

		var currentBoard = [];
		var currentTurn = 0; //0:Black 1:White
		var validMoves = [];
		var size = size;
		var boardCellColor = "#333";
		var boardCellColorEven = "#999";
		var self = this;
		
		console.log(this.canvas.width + "x" + this.canvas.height);

		this.canvas.addEventListener('mousedown', function(evt) {
			var rect = evt.currentTarget.getBoundingClientRect();
			var x = evt.clientX - rect.left;
			var y = evt.clientY - rect.top;
			
			console.log(evt.clientX + "-" + rect.left +"=" + x);
			console.log(evt.clientY + "-" + rect.top +"=" + y);
			onPiecePut.call(self,x,y);
		});
		
		function onPiecePut(x,y) {
			var row = size - parseInt((this.canvas.height - y) / (this.canvas.height / size)) - 1;
			var col = size - parseInt((this.canvas.width - x) / (this.canvas.width / size)) - 1;

			var isValid = false;
			var index = row * size + col;
			for(var i in validMoves) {
				if(validMoves[i] == index) {
					isValid = true;
					break;
				}
			}

			if(isValid == false) return;

			this.listener.onPiecePut(currentTurn, currentBoard, row,col);
		}

		function drawBoard() {
			var even = false;

			for(var r = 0; r < size;++r) {
				var rowPosition = r * (this.canvas.width / size);
				for(var c=0;c < size;++c) {
					var colPosition = c * (this.canvas.height / size);
					if(even) {
						this.ctx.fillStyle = boardCellColorEven;
					} else{
						this.ctx.fillStyle = boardCellColor;
					}
					even = !even;
					this.ctx.fillRect(colPosition,rowPosition, this.canvas.width / size, this.canvas.height / size);
				}
				even = !even;
			}
		};

		this.setBoardCellColor = function(cell, even) {
			boardCellColor = cell;
			boardCellColorEven = even; 
		};

		function drawPiece(r,c,piece) {
			var rowPosition = r * (this.canvas.width / size);
			var colPosition = c * (this.canvas.height / size);
			this.ctx.beginPath();
			if(piece === WHITE) {
				this.ctx.fillStyle = WHITE_COLOR;
			} else if (piece === BLACK) {
				this.ctx.fillStyle = BLACK_COLOR;
			}
			this.ctx.arc(colPosition + (this.canvas.height / size / 2), rowPosition + (this.canvas.width /  size / 2), this.canvas.width/ size/2 - (this.canvas.width /size /2 * (1-PIECE_MARGIN)), 0, 2*Math.PI);
			this.ctx.fill();
		};


		function reversePiece(r,c,from,to) {
			var rowPosition = r * (this.canvas.width / size);
			var colPosition = c * (this.canvas.height / size);
			this.ctx.beginPath();
			if(to === WHITE) {
				this.ctx.fillStyle = WHITE_COLOR;
				this.ctx.strokeStyle = BLACK_COLOR;
			} else if (to === BLACK) {
				this.ctx.fillStyle = BLACK_COLOR;
				this.ctx.strokeStyle = WHITE_COLOR;
			}
			this.ctx.arc(colPosition + (this.canvas.height / size / 2), rowPosition + (this.canvas.width /  size / 2), this.canvas.width/ size/2 - (this.canvas.width /size /2 * (1-PIECE_MARGIN)), 0, 2*Math.PI);
			this.ctx.fill();
			this.ctx.lineWidth = 2;
			this.ctx.stroke();
		};
		this.redraw = function() {
			this.drawPieces(currentTurn, currentBoard,validMoves);
		};
		this.drawPieces = function(turn, pieces, vMoves) {
			drawBoard.call(self);
			validMoves = vMoves;

			var lastBoardState = currentBoard.slice(0); // clone the current board state
			currentTurn = turn;
			currentBoard = pieces;

			for(var r = 0 ; r < size; r++) {
				for(var c = 0 ; c < size; c++) {
					var index = r * size + c;
					var piece = pieces[index];

					if(lastBoardState.length == currentBoard.length) {
						var previousPiece = lastBoardState[index];
						//Catch pieces only needed to reverse
						if(piece !== NONE && previousPiece !== NONE && piece !== previousPiece) {
							if(previousPiece === WHITE) {
								//Transitioning White to Black
								reversePiece.call(self, r, c, WHITE, BLACK);
							} else if(previousPiece === BLACK) {
								reversePiece.call(self, r, c, BLACK, WHITE);
							}
						} else{
							if(piece === WHITE) {
								drawPiece.call(self,r, c, WHITE);
							} else if (piece === BLACK) {
								drawPiece.call(self,r, c, BLACK);
							}
						}
					} else{
						if(piece === WHITE) {
							drawPiece.call(self, r,c,WHITE);
						} else if (piece === BLACK) {
							drawPiece.call(self, r,c,BLACK);
						}
					}
				}
			}

			for(var i in validMoves) {
				var row = parseInt(validMoves[i] / size);
				var col = parseInt(validMoves[i] - (row * size));

				var rowPosition = row * (this.canvas.width / size);
				var colPosition = col * (this.canvas.height / size);

				this.ctx.beginPath();
				this.ctx.fillStyle = VALID_COLOR;
				this.ctx.arc(colPosition + (this.canvas.height / size / 2), rowPosition + (this.canvas.width /  size / 2), this.canvas.width/ size/2 - (this.canvas.width / size / 3), 0, 2*Math.PI);
				this.ctx.fill();
			}

		};
		
		this.saveAsImage = function() {
			var w=window.open('about:blank','image from canvas');
			w.document.write("<img src='"+this.canvas.toDataURL("image/png")+"' alt='from canvas'/>");
		};
	};
	
		var gameBoard = null;
		var relayingSubscription =null;
		
		gameBoard = new GameBoard("gameBoard", 8, {
 			onPiecePut : function(turn, board, row, col) {
 				console.log(board);
 				
 				var num = new Uint16Array(10);
 				
 				for(var i=0;i<8;++i) {
 					var binaryString = "";
 					for(var j=0;j<8;++j) {
 						var c = board[i*8+j];
 						if(c === "B") {
 	 						binaryString += "01";
 	 					} else if (c=== "W") {
 	 						binaryString += "10";
 	 					} else {
 	 						binaryString += "00";
 	 					}
 					}
 					console.log(binaryString);
 					num[i] = parseInt(binaryString, 2);
 				}
 				num[8] = turn;
 				num[9] = row *8 + col;
 				console.log(num);
 				console.log("Put piece at (row,col): " + row + "," + col);
 				
 				var xhr = new XMLHttpRequest();
 		        xhr.open('POST', '/game/put', true);
 		        xhr.responseType = 'arraybuffer';
 		        
 		        
				xhr.onload = function(e) {
					if (this.status == 200) {
		        		onBoardDataReceived(xhr.response);
		          	}
				};
				
				xhr.send(num);
 			}
 		});
		
		 window.addEventListener('resize', resizeCanvas, false);
         
			
         function resizeCanvas() {
        	 var canvas = document.getElementById('gameBoard');
        	 var baseLength = ((window.innerWidth-20) > (window.innerHeight - 100)) ? (window.innerHeight-100) : (window.innerWidth-20);
        	 canvas.width = baseLength;
        	 canvas.height = canvas.width;
        	 gameBoard.redraw();
         }
         
         resizeCanvas();
         
         var xhr = new XMLHttpRequest();
         xhr.open('POST', '/game/new', true);
         xhr.responseType = 'arraybuffer';

         function onBoardDataReceived(game) {
       		var pieces = [];
       		var validMoves = [];
       		var num = new Uint16Array(game, 0);
       		var black = 0, white = 0;
       		for(var i = 0; i < num.length-1; ++i) {
       			var n = num[i];
       			
       			var binaryString = (("0000000000000000" + n.toString(2)).slice(-16));
       			console.log(i + "  " + binaryString);
       			
       			for (var j = 0, len = binaryString.length; j < len; j=j+2) {
       				var cell = binaryString[j] + binaryString[j+1];
       				
       				if(cell === '01') {
       					pieces.push("B");
       					black++;
       				} else if(cell === '10') {
       					pieces.push("W");
       					white++;
       				} else if(cell === '11') {
       					pieces.push("N");
       					validMoves.push(i*8+j/2);
       				} else {
       					pieces.push("N");
       				}
       			}
       		}
       		var who = num[num.length-1];
       		
       		console.log("WHO(0:B,1:W,2:GAMEOVER):" + who);
       		console.log("PIECES:" + pieces);
       		console.log("VALID MOVES:" + validMoves);
       		console.log("Black:" + black);
       		console.log("White:" + white);
       		
       		gameBoard.drawPieces(who, pieces, validMoves);
       		
       		if(who == 2) {
       			var winner = "Black";
       			if(black < white) {
       				winner = "White";
       			} else {
       				winner = "Both";
       			}
       			alert("Game Over! Winner is " + winner);
       		}
         }
         
         xhr.onload = function(e) {
           	if (this.status == 200) {
        		onBoardDataReceived(xhr.response);
          	}
         };

         xhr.send();
         
         (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
       	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
       	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
       	  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
       	
       	  ga('create', 'UA-51540987-10', 'auto');
       	  ga('send', 'pageview');
	</script>
</body>
</html>
